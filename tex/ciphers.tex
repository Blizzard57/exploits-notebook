\chapter{Encryption and Decryption}


\section{Overview}
Cryptography is traditionally associated with opening a message with a key, which is only known by the parties in the communication and no once else. This was true at that time and in some sense still is, but nowadays any form of data ( or information ) is protected with a cipher which helps in its secure transmission. Hence the definition has changed over the years.

\begin{definition}[Cryptography]{def:cryptography}
    It is the practice and study of techniques for secure communication in the presence of third parties called adversaries
\end{definition}

\noindent From the above definition, it can clearly be seen how much it has changed over the years. This should be kept in mind when studying cryptography.

\subsection{Uses}
There are many examples where cryptography is used. It is almost as if every technology that exists wants to protect their information.

\begin{example}[]{exm:uses-of-cryptography-on-web-protocols}
    FFor all types of communication via web, cryptography is used.
    \begin{itemize}
        \item Web Traffic : HTTPS Protocol
        \item Wireless Traffic
              \begin{itemize}
                  \item WiFi Traffic : 802.11 a/b/g/n
                  \item Telephone Signal : GSM
              \end{itemize}
    \end{itemize}
\end{example}

\begin{example}[]{emp:file-encryption-system-eefs}
    EEFS file encryption and Truecrypt are used for protection of files.
\end{example}

\begin{example}[]{exm:content-protection-systems-cd-dvd}
    For content protection (DVDs and CDs with copyright media) these technologies are used:
    \begin{itemize}
        \item CSS: Content Scrambling System ( Easily broken )
        \item AACS: Advanced Access Content System ( Not that easy)
    \end{itemize}
\end{example}

\noindent These are some of the examples of how cryptography is used everywhere. Hence understanding them is very important, and so is knowing how vulnerable they are. This can be the difference between building a robust system with good security and one which is easily exploited.



\section{Historical Ciphers}
In this chapter, historical ciphers will be explored. This is the time period where technology and digital communication were not prevalent, and hence these will be a product of the time when they were developed.


\subsection{Substitution Cipher}
This is one of the simplest ciphers that exists. It uses a 26 byte key which is a map from set of alphabets to itself.

\begin{definition}[]{def-substitution-cipher}
    Mathemtical definition of the substitution cipher is as follows:
    \begin{itemize}
        \item G : Set of ASCII Characters
        \item $f : G \rightarrow G$, $f$ is bijective, such that
        \item $f(\alpha) = \beta$
    \end{itemize}

    \noindent$f \rightarrow$ Substitution\ Cipher
\end{definition}

\noindent As it can be seen, the substitution cipher is a hash table, which stores the mapping of every character.

\subsubsection{Code}
This is a sample code on how the substitution cipher encodes. In this only small alphabets are taken into consideration.

\lstinputlisting[basicstyle=Large,style=py]{code/ciphers/substitution_encoder.py}


\subsection{Rot - X}
There is a keyless version of the substitution cipher which is an even simpler version of the original cipher. In this, instead of a random key table, here it is a rotation by X (an integer), around which the alphabets are wrapped.

\begin{definition}[]{def:rot-x-cipher}
    Mathemtical definition of the Rot-X cipher is as follows :
    \begin{itemize}
        \item G : Set of ASCII Characters
        \item $f : G \rightarrow G,$
        \item $f(\alpha) = (\alpha + X)\ mod\ 26 $
    \end{itemize}
    \noindent $f \rightarrow$ Rot-X\ Cipher
\end{definition}

\subsubsection{Code}
A sample code is written for it, even though it is not required. But well here it is:

\lstinputlisting[basicstyle=Large,style=py]{code/ciphers/rotx_encoder.py}


\subsection{Caesar Cipher}
A Rot-3 cipher is known as a Caesar cipher. This cipher does not even have a key, and hence is technically not a cipher, but came before the generalization Rot-X and hence was widely used at some point in time and still is used as an introduction to ciphers in CTFs.

\subsubsection{Breaking the Cipher}
This is one of the easiest ciphers to break. It is done using a method known as frequency analysis.

\begin{definition}
    Frequency analysis is the study of letters or groups of letters contained in a ciphertext in an attempt to partially reveal the message.
\end{definition}

\noindent So using frequency analysis, the frequency of letters is done on the ciphertext and is mapped to what is standard for the English language and hence the plaintext known by replacing the letters with their maps.


Here is an example to clear the doubts :

\begin{example}
    dLet us take ciphertext (c) be :
    \begin{verbatim}
LIVITCSWPIYVEWHEVSRIQMXLEYVEOIEWHRXEXIPFEMVEWHKVSTYLXZIXLIKI
IXPIJVSZEYPERRGERIMWQLMGLMXQERIWGPSRIHMXQEREKIETXMJTPRGEVEKE
ITREWHEXXLEXXMZITWAWSQWXSWEXTVEPMRXRSJGSTVRIEYVIEXCVMUIMWERG
MIWXMJMGCSMWXSJOMIQXLIVIQIVIXQSVSTWHKPEGARCSXRWIEVSWIIBXVIZM
XFSJXLIKEGAEWHEPSWYSWIWIEVXLISXLIVXLIRGEPIRQIVIIBGIIHMWYPFLE
VHEWHYPSRRFQMXLEPPXLIECCIEVEWGISJKTVWMRLIHYSPHXLIQIMYLXSJXLI
MWRIGXQEROIVFVIZEVAEKPIEWHXEAMWYEPPXLMWYRMWXSGSWRMHIVEXMSWMG
STPHLEVHPFKPEZINTCMXIVJSVLMRSCMWMSWVIRCIGXMWYMX
    \end{verbatim}

    \noindent I is the most common letter that appears here. It is known that e is the most common English alphabet, and hence I can be replaced with e. Similarly looking at the most common two letter sequence it is XL which can be replaced with in.

    Going on like this, we can successfully find the substitution, which is as follows:
    \begin{verbatim}
Hereupon Legrand arose, with a grave and stately air, and 
brought me the beetle from a glass case in which it was 
enclosed. It was a beautiful scarabaeus, and, at that time, 
unknown to naturalists—of course a great prize in a scientific 
point of view. There were two round black spots near one 
extremity of the back, and a long one near the other. The 
scales were exceedingly hard and glossy, with all the 
appearance of burnished gold. The weight of the insect was 
very remarkable, and, taking all things into consideration, 
I could hardly blame Jupiter for his opinion respecting it.
    \end{verbatim}

    \noindent For more in depth solution, go to :
    \href {https://en.wikipedia.org/wiki/Frequency_analysis#An_example}{Frequency Analysis Wiki}
\end{example}

\subsubsection{Code}
Code for the frequency analysis tool is taken from \href{https://github.com/CodeDrome/frequency-analysis-python}{CodeDrome}:
\lstinputlisting[basicstyle=Large,style=py]{code/ciphers/frequency_analysis.py}

\subsubsection{Working}
The code above initially makes a frequency analysis dictionary with the help of a language text (preferably large), after which it stores it in a JSON. Then that dictionary is used to decode an encoded ciphertext.


\subsection{Vigenère Cipher}
Vigenère Cipher is one of the more competent of the ciphers created by Blaise de Vigenère, who was a French cryptographer. In this cipher, the key is repeated till its size is equal to that of the message. After which it is added to message alphabet by alphabet.

\begin{definition}[Vigenere Cipher]{def:vigenere-cipher}
    Definition of Vigenère Cipher:
    \begin{itemize}
        \item Pad key till length(key) = length(message)
        \item ciphertext = key $+_{26}$ message
    \end{itemize}
\end{definition}

\noindent In this the key is padded to make it equal to the length of the message. Hence, the key length cannot be greater than that of the cipher (It can be, but won't affect the working of the cipher).

\begin{example}
    lLets take an example of the cipher, to know how it works.
    \begin{verbatim}
        key = 'mykey'
        message = 'plztransferthis'    
        len(key) != len(message)
        
        padded_key = 'mykeymykeymykey'
        message    = 'plztransferthis'
        --------------------------------  + mod 26
        ciphertext = 'bjjxpmlcjcdrrmq'
    \end{verbatim}
\end{example}

\subsubsection{Code}
Now that the working of the cipher is known, here is a code for the same:

\lstinputlisting[basicstyle=Large,style=py]{code/ciphers/vigenere_encoder.py}

\subsubsection{Breaking the Cipher}

\paragraph{} Start by assuming that the length of the key is known to be $l$. Hence, in the ciphertext every $l^{th}$ character is coded by the same letter. Therefore, the ciphertext formed from this is a Rot-X.
\paragraph{} This can be solved using frequency analysis. So the X is now known, the character representation of that X is a letter of the key. Do this for every $l$ letters till the complete key is found, after which the cipher can be decoded.
\paragraph{} In this, an assumption was made that the length of the key was known, which is not the case. So, start with  $l = 1$, till a comprehendible message is found.

\subsubsection{Code}
This is the code that solves the Vigenère cipher, which is taken from the \href{https://github.com/alpha-k911/Vigenere-Cipher-Decrypter}{alpha-k911 github}.

\lstinputlisting[basicstyle=Large,style=py]{code/ciphers/vigenere_decoder.py}


\subsection{Rotor Machines}

During the renaissance, motors were name of the game. So naturally, people wanted to use it in a cipher scheme. Due to that a rotor machine cipher was formed.

One of the earlier and simpler rotor machine was the Hebern machine. It has a single rotor and hence encodes a simple 'rotating' substitution table.

\begin{example}
    So the working of a Hebern machine is explained here. The machine encodes a substitution cipher, whose table moves every time a letter is typed.
    \begin{verbatim}
        N                 V                 .
        K                 N                 V
        P                 K                 N
        T  Letter Typed   P  Letter Typed   K
        O  ------------>  T  ------------>  P
        .                 O                 T
        .                 .                 O
        .                 .                 .
        V                 .                 .

        Hence, if m = 'CCC', 
        then c = 'PKN'
    \end{verbatim}
\end{example}

\noindent This is more complex than the standard substitution cipher as same character is encoded to different character according to position of the rotor. Therefore the definition of a Hebern machine is as follows:

\begin{definition}[Hebern Machine]{def:hebern-machine}
    The definition of the Hebern machine, therefore is:
    \begin{itemize}
        \item G : Set of ASCII Characters
        \item $f : G \rightarrow G$, $f$ is bijective, such that
        \item $f(\alpha + pos(\alpha)) = \beta$;
        \item $pos(\alpha) \rightarrow$ Index of $\alpha$ in the plaintext
    \end{itemize}
\end{definition}

\subsubsection{Code}
Now that the definition of the Hebern machine is known, this is the code:

\lstinputlisting[basicstyle=Large,style=py]{code/ciphers/hebern_encoder.py}

\noindent It seems, as if there is no difference between the code of a substitution cipher and this one, but there is. In this the position of the letter is taken into consideration, thus making it a Hebern machine.


\subsection{Enigma Machine}

\paragraph{} One of the most popular rotor machine. This was used by the Germans in the World War 2 for intra-communication. This machine had 3-5 rotors in it which would rotate at different speeds and would thus generate a very complicated (for that time) cipher text which was hard to break.

\paragraph{} This machine was reverse engineered and decrypted by a British mathematician Alan Turing, who is very famously known for the Turing machine and the Church-Turing hypothesis.

\subsubsection{Code}
This is a sample code for Enigma machine. If a more detailed and better understanding for the Enigma code is wanted, it can be found on \href{https://github.com/torognes/enigma}{torognes github}.

\lstinputlisting[basicstyle=Large,style=py]{code/ciphers/enigma_encoder.py}
